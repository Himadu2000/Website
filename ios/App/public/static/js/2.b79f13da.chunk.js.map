{"version":3,"sources":["../node_modules/@ionic/core/dist/esm/legacy/index-0303391f.js","../node_modules/@ionic/core/dist/esm/legacy/swipe-back-8dc047dc.js"],"names":["__webpack_require__","r","__webpack_exports__","d","GESTURE_CONTROLLER","createGesture","_sPassive","_chunk_f257aad1_js__WEBPACK_IMPORTED_MODULE_0__","GestureController","this","gestureId","requestedStart","Map","disabledGestures","disabledScroll","Set","prototype","config","GestureDelegate","newID","name","priority","disableScroll","createBlocker","opts","BlockerDelegate","disable","start","gestureName","id","canStart","set","delete","capture","maxPriority","forEach","value","Math","max","capturedId","clear","event","CustomEvent","detail","document","dispatchEvent","release","undefined","disableGesture","get","add","enableGesture","size","body","classList","BACKDROP_NO_SCROLL","enableScroll","remove","isDisabled","isCaptured","isScrollDisabled","disabled","ctrl","captured","destroy","block","_i","_a","length","gesture","unblock","addEventListener","el","eventName","callback","listenerOpts","node","Object","defineProperty","e","supportsPassive","passive","MOUSE_WAIT","getDocument","Document","ownerDocument","finalConfig","assign","direction","gesturePriority","maxAngle","threshold","onWillStart","onStart","onEnd","notCaptured","onMove","type","startX","startY","startTimeStamp","currentX","currentY","velocityX","velocityY","deltaX","deltaY","timeStamp","data","pointerEvents","pointerDown","pointerMove","pointerUp","options","rmTouchStart","rmTouchMove","rmTouchEnd","rmTouchCancel","rmMouseStart","rmMouseMove","rmMouseUp","lastTouchEvent","handleTouchStart","ev","Date","now","handleTouchEnd","handleMouseDown","handleMouseUp","stopTouch","stopMouse","stop","setDisabled","createPointerEvents","hasStartedPan","hasFiredStart","updateDetail","tryToCapturePan","pan","hasCapturedPan","isMoveQueued","calcGestureData","fireOnMove","detect","isGesture","reset","thresh","radians","PI","isDirX","maxCosine","cos","dirty","isPan","x","y","distance","hypotenuse","sqrt","cosine","getDirection","createPanRecognizer","then","fireOnStart","tmpHasCaptured","tmpHasFiredStart","prevX","prevY","prevT","timeDelta","changedTouches","touch","clientX","clientY","pageX","pageY","createSwipeBackGesture","_index_0303391f_js__WEBPACK_IMPORTED_MODULE_2__","canStartHandler","onStartHandler","onMoveHandler","onEndHandler","win","defaultView","stepValue","innerWidth","delta","width","velocity","z","shouldComplete","missingDistance","realDur","dur","abs","min"],"mappings":"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","file":"static/js/2.b79f13da.chunk.js","sourcesContent":["import { w as writeTask } from './chunk-f257aad1.js';\nimport './chunk-1074393c.js';\n\nvar GestureController =\n/** @class */\nfunction () {\n  function GestureController() {\n    this.gestureId = 0;\n    this.requestedStart = new Map();\n    this.disabledGestures = new Map();\n    this.disabledScroll = new Set();\n  }\n  /**\n   * Creates a gesture delegate based on the GestureConfig passed\n   */\n\n\n  GestureController.prototype.createGesture = function (config) {\n    return new GestureDelegate(this, this.newID(), config.name, config.priority || 0, !!config.disableScroll);\n  };\n  /**\n   * Creates a blocker that will block any other gesture events from firing. Set in the ion-gesture component.\n   */\n\n\n  GestureController.prototype.createBlocker = function (opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    return new BlockerDelegate(this, this.newID(), opts.disable, !!opts.disableScroll);\n  };\n\n  GestureController.prototype.start = function (gestureName, id, priority) {\n    if (!this.canStart(gestureName)) {\n      this.requestedStart.delete(id);\n      return false;\n    }\n\n    this.requestedStart.set(id, priority);\n    return true;\n  };\n\n  GestureController.prototype.capture = function (gestureName, id, priority) {\n    if (!this.start(gestureName, id, priority)) {\n      return false;\n    }\n\n    var requestedStart = this.requestedStart;\n    var maxPriority = -10000;\n    requestedStart.forEach(function (value) {\n      maxPriority = Math.max(maxPriority, value);\n    });\n\n    if (maxPriority === priority) {\n      this.capturedId = id;\n      requestedStart.clear();\n      var event = new CustomEvent('ionGestureCaptured', {\n        detail: {\n          gestureName: gestureName\n        }\n      });\n      document.dispatchEvent(event);\n      return true;\n    }\n\n    requestedStart.delete(id);\n    return false;\n  };\n\n  GestureController.prototype.release = function (id) {\n    this.requestedStart.delete(id);\n\n    if (this.capturedId === id) {\n      this.capturedId = undefined;\n    }\n  };\n\n  GestureController.prototype.disableGesture = function (gestureName, id) {\n    var set = this.disabledGestures.get(gestureName);\n\n    if (set === undefined) {\n      set = new Set();\n      this.disabledGestures.set(gestureName, set);\n    }\n\n    set.add(id);\n  };\n\n  GestureController.prototype.enableGesture = function (gestureName, id) {\n    var set = this.disabledGestures.get(gestureName);\n\n    if (set !== undefined) {\n      set.delete(id);\n    }\n  };\n\n  GestureController.prototype.disableScroll = function (id) {\n    this.disabledScroll.add(id);\n\n    if (this.disabledScroll.size === 1) {\n      document.body.classList.add(BACKDROP_NO_SCROLL);\n    }\n  };\n\n  GestureController.prototype.enableScroll = function (id) {\n    this.disabledScroll.delete(id);\n\n    if (this.disabledScroll.size === 0) {\n      document.body.classList.remove(BACKDROP_NO_SCROLL);\n    }\n  };\n\n  GestureController.prototype.canStart = function (gestureName) {\n    if (this.capturedId !== undefined) {\n      // a gesture already captured\n      return false;\n    }\n\n    if (this.isDisabled(gestureName)) {\n      return false;\n    }\n\n    return true;\n  };\n\n  GestureController.prototype.isCaptured = function () {\n    return this.capturedId !== undefined;\n  };\n\n  GestureController.prototype.isScrollDisabled = function () {\n    return this.disabledScroll.size > 0;\n  };\n\n  GestureController.prototype.isDisabled = function (gestureName) {\n    var disabled = this.disabledGestures.get(gestureName);\n\n    if (disabled && disabled.size > 0) {\n      return true;\n    }\n\n    return false;\n  };\n\n  GestureController.prototype.newID = function () {\n    this.gestureId++;\n    return this.gestureId;\n  };\n\n  return GestureController;\n}();\n\nvar GestureDelegate =\n/** @class */\nfunction () {\n  function GestureDelegate(ctrl, id, name, priority, disableScroll) {\n    this.id = id;\n    this.name = name;\n    this.disableScroll = disableScroll;\n    this.priority = priority * 1000000 + id;\n    this.ctrl = ctrl;\n  }\n\n  GestureDelegate.prototype.canStart = function () {\n    if (!this.ctrl) {\n      return false;\n    }\n\n    return this.ctrl.canStart(this.name);\n  };\n\n  GestureDelegate.prototype.start = function () {\n    if (!this.ctrl) {\n      return false;\n    }\n\n    return this.ctrl.start(this.name, this.id, this.priority);\n  };\n\n  GestureDelegate.prototype.capture = function () {\n    if (!this.ctrl) {\n      return false;\n    }\n\n    var captured = this.ctrl.capture(this.name, this.id, this.priority);\n\n    if (captured && this.disableScroll) {\n      this.ctrl.disableScroll(this.id);\n    }\n\n    return captured;\n  };\n\n  GestureDelegate.prototype.release = function () {\n    if (this.ctrl) {\n      this.ctrl.release(this.id);\n\n      if (this.disableScroll) {\n        this.ctrl.enableScroll(this.id);\n      }\n    }\n  };\n\n  GestureDelegate.prototype.destroy = function () {\n    this.release();\n    this.ctrl = undefined;\n  };\n\n  return GestureDelegate;\n}();\n\nvar BlockerDelegate =\n/** @class */\nfunction () {\n  function BlockerDelegate(ctrl, id, disable, disableScroll) {\n    this.id = id;\n    this.disable = disable;\n    this.disableScroll = disableScroll;\n    this.ctrl = ctrl;\n  }\n\n  BlockerDelegate.prototype.block = function () {\n    if (!this.ctrl) {\n      return;\n    }\n\n    if (this.disable) {\n      for (var _i = 0, _a = this.disable; _i < _a.length; _i++) {\n        var gesture = _a[_i];\n        this.ctrl.disableGesture(gesture, this.id);\n      }\n    }\n\n    if (this.disableScroll) {\n      this.ctrl.disableScroll(this.id);\n    }\n  };\n\n  BlockerDelegate.prototype.unblock = function () {\n    if (!this.ctrl) {\n      return;\n    }\n\n    if (this.disable) {\n      for (var _i = 0, _a = this.disable; _i < _a.length; _i++) {\n        var gesture = _a[_i];\n        this.ctrl.enableGesture(gesture, this.id);\n      }\n    }\n\n    if (this.disableScroll) {\n      this.ctrl.enableScroll(this.id);\n    }\n  };\n\n  BlockerDelegate.prototype.destroy = function () {\n    this.unblock();\n    this.ctrl = undefined;\n  };\n\n  return BlockerDelegate;\n}();\n\nvar BACKDROP_NO_SCROLL = 'backdrop-no-scroll';\nvar GESTURE_CONTROLLER = new GestureController();\n\nfunction addEventListener(el, eventName, callback, opts) {\n  // use event listener options when supported\n  // otherwise it's just a boolean for the \"capture\" arg\n  var listenerOpts = supportsPassive(el) ? {\n    'capture': !!opts.capture,\n    'passive': !!opts.passive\n  } : !!opts.capture;\n  var add;\n  var remove;\n\n  if (el['__zone_symbol__addEventListener']) {\n    add = '__zone_symbol__addEventListener';\n    remove = '__zone_symbol__removeEventListener';\n  } else {\n    add = 'addEventListener';\n    remove = 'removeEventListener';\n  }\n\n  el[add](eventName, callback, listenerOpts);\n  return function () {\n    el[remove](eventName, callback, listenerOpts);\n  };\n}\n\nvar _sPassive;\n\nfunction supportsPassive(node) {\n  if (_sPassive === undefined) {\n    try {\n      var opts = Object.defineProperty({}, 'passive', {\n        get: function get() {\n          _sPassive = true;\n        }\n      });\n      node.addEventListener('optsTest', function () {\n        return;\n      }, opts);\n    } catch (e) {\n      _sPassive = false;\n    }\n  }\n\n  return !!_sPassive;\n}\n\nvar MOUSE_WAIT = 2000;\n\nfunction createPointerEvents(el, pointerDown, pointerMove, pointerUp, options) {\n  var rmTouchStart;\n  var rmTouchMove;\n  var rmTouchEnd;\n  var rmTouchCancel;\n  var rmMouseStart;\n  var rmMouseMove;\n  var rmMouseUp;\n  var lastTouchEvent = 0;\n\n  function handleTouchStart(ev) {\n    lastTouchEvent = Date.now() + MOUSE_WAIT;\n\n    if (!pointerDown(ev)) {\n      return;\n    }\n\n    if (!rmTouchMove && pointerMove) {\n      rmTouchMove = addEventListener(el, 'touchmove', pointerMove, options);\n    }\n\n    if (!rmTouchEnd) {\n      rmTouchEnd = addEventListener(el, 'touchend', handleTouchEnd, options);\n    }\n\n    if (!rmTouchCancel) {\n      rmTouchCancel = addEventListener(el, 'touchcancel', handleTouchEnd, options);\n    }\n  }\n\n  function handleMouseDown(ev) {\n    if (lastTouchEvent > Date.now()) {\n      return;\n    }\n\n    if (!pointerDown(ev)) {\n      return;\n    }\n\n    if (!rmMouseMove && pointerMove) {\n      rmMouseMove = addEventListener(getDocument(el), 'mousemove', pointerMove, options);\n    }\n\n    if (!rmMouseUp) {\n      rmMouseUp = addEventListener(getDocument(el), 'mouseup', handleMouseUp, options);\n    }\n  }\n\n  function handleTouchEnd(ev) {\n    stopTouch();\n\n    if (pointerUp) {\n      pointerUp(ev);\n    }\n  }\n\n  function handleMouseUp(ev) {\n    stopMouse();\n\n    if (pointerUp) {\n      pointerUp(ev);\n    }\n  }\n\n  function stopTouch() {\n    if (rmTouchMove) {\n      rmTouchMove();\n    }\n\n    if (rmTouchEnd) {\n      rmTouchEnd();\n    }\n\n    if (rmTouchCancel) {\n      rmTouchCancel();\n    }\n\n    rmTouchMove = rmTouchEnd = rmTouchCancel = undefined;\n  }\n\n  function stopMouse() {\n    if (rmMouseMove) {\n      rmMouseMove();\n    }\n\n    if (rmMouseUp) {\n      rmMouseUp();\n    }\n\n    rmMouseMove = rmMouseUp = undefined;\n  }\n\n  function stop() {\n    stopTouch();\n    stopMouse();\n  }\n\n  function setDisabled(disabled) {\n    if (disabled) {\n      if (rmTouchStart) {\n        rmTouchStart();\n      }\n\n      if (rmMouseStart) {\n        rmMouseStart();\n      }\n\n      rmTouchStart = rmMouseStart = undefined;\n      stop();\n    } else {\n      if (!rmTouchStart) {\n        rmTouchStart = addEventListener(el, 'touchstart', handleTouchStart, options);\n      }\n\n      if (!rmMouseStart) {\n        rmMouseStart = addEventListener(el, 'mousedown', handleMouseDown, options);\n      }\n    }\n  }\n\n  function destroy() {\n    setDisabled(true);\n    pointerUp = pointerMove = pointerDown = undefined;\n  }\n\n  return {\n    setDisabled: setDisabled,\n    stop: stop,\n    destroy: destroy\n  };\n}\n\nfunction getDocument(node) {\n  return node instanceof Document ? node : node.ownerDocument;\n}\n\nfunction createPanRecognizer(direction, thresh, maxAngle) {\n  var radians = maxAngle * (Math.PI / 180);\n  var isDirX = direction === 'x';\n  var maxCosine = Math.cos(radians);\n  var threshold = thresh * thresh;\n  var startX = 0;\n  var startY = 0;\n  var dirty = false;\n  var isPan = 0;\n  return {\n    start: function start(x, y) {\n      startX = x;\n      startY = y;\n      isPan = 0;\n      dirty = true;\n    },\n    detect: function detect(x, y) {\n      if (!dirty) {\n        return false;\n      }\n\n      var deltaX = x - startX;\n      var deltaY = y - startY;\n      var distance = deltaX * deltaX + deltaY * deltaY;\n\n      if (distance < threshold) {\n        return false;\n      }\n\n      var hypotenuse = Math.sqrt(distance);\n      var cosine = (isDirX ? deltaX : deltaY) / hypotenuse;\n\n      if (cosine > maxCosine) {\n        isPan = 1;\n      } else if (cosine < -maxCosine) {\n        isPan = -1;\n      } else {\n        isPan = 0;\n      }\n\n      dirty = false;\n      return true;\n    },\n    isGesture: function isGesture() {\n      return isPan !== 0;\n    },\n    getDirection: function getDirection() {\n      return isPan;\n    }\n  };\n}\n\nfunction createGesture(config) {\n  var finalConfig = Object.assign({\n    disableScroll: false,\n    direction: 'x',\n    gesturePriority: 0,\n    passive: true,\n    maxAngle: 40,\n    threshold: 10\n  }, config);\n  var canStart = finalConfig.canStart;\n  var onWillStart = finalConfig.onWillStart;\n  var onStart = finalConfig.onStart;\n  var onEnd = finalConfig.onEnd;\n  var notCaptured = finalConfig.notCaptured;\n  var onMove = finalConfig.onMove;\n  var threshold = finalConfig.threshold;\n  var detail = {\n    type: 'pan',\n    startX: 0,\n    startY: 0,\n    startTimeStamp: 0,\n    currentX: 0,\n    currentY: 0,\n    velocityX: 0,\n    velocityY: 0,\n    deltaX: 0,\n    deltaY: 0,\n    timeStamp: 0,\n    event: undefined,\n    data: undefined\n  };\n  var pointerEvents = createPointerEvents(finalConfig.el, pointerDown, pointerMove, pointerUp, {\n    capture: false\n  });\n  var pan = createPanRecognizer(finalConfig.direction, finalConfig.threshold, finalConfig.maxAngle);\n  var gesture = GESTURE_CONTROLLER.createGesture({\n    name: config.gestureName,\n    priority: config.gesturePriority,\n    disableScroll: config.disableScroll\n  });\n  var hasCapturedPan = false;\n  var hasStartedPan = false;\n  var hasFiredStart = true;\n  var isMoveQueued = false;\n\n  function pointerDown(ev) {\n    var timeStamp = now(ev);\n\n    if (hasStartedPan || !hasFiredStart) {\n      return false;\n    }\n\n    updateDetail(ev, detail);\n    detail.startX = detail.currentX;\n    detail.startY = detail.currentY;\n    detail.startTimeStamp = detail.timeStamp = timeStamp;\n    detail.velocityX = detail.velocityY = detail.deltaX = detail.deltaY = 0;\n    detail.event = ev; // Check if gesture can start\n\n    if (canStart && canStart(detail) === false) {\n      return false;\n    } // Release fallback\n\n\n    gesture.release(); // Start gesture\n\n    if (!gesture.start()) {\n      return false;\n    }\n\n    hasStartedPan = true;\n\n    if (threshold === 0) {\n      return tryToCapturePan();\n    }\n\n    pan.start(detail.startX, detail.startY);\n    return true;\n  }\n\n  function pointerMove(ev) {\n    // fast path, if gesture is currently captured\n    // do minimum job to get user-land even dispatched\n    if (hasCapturedPan) {\n      if (!isMoveQueued && hasFiredStart) {\n        isMoveQueued = true;\n        calcGestureData(detail, ev);\n        writeTask(fireOnMove);\n      }\n\n      return;\n    } // gesture is currently being detected\n\n\n    calcGestureData(detail, ev);\n\n    if (pan.detect(detail.currentX, detail.currentY)) {\n      if (!pan.isGesture() || !tryToCapturePan()) {\n        abortGesture();\n      }\n    }\n  }\n\n  function fireOnMove() {\n    // Since fireOnMove is called inside a RAF, onEnd() might be called,\n    // we must double check hasCapturedPan\n    if (!hasCapturedPan) {\n      return;\n    }\n\n    isMoveQueued = false;\n\n    if (onMove) {\n      onMove(detail);\n    }\n  }\n\n  function tryToCapturePan() {\n    if (gesture && !gesture.capture()) {\n      return false;\n    }\n\n    hasCapturedPan = true;\n    hasFiredStart = false; // reset start position since the real user-land event starts here\n    // If the pan detector threshold is big, not resetting the start position\n    // will cause a jump in the animation equal to the detector threshold.\n    // the array of positions used to calculate the gesture velocity does not\n    // need to be cleaned, more points in the positions array always results in a\n    // more accurate value of the velocity.\n\n    detail.startX = detail.currentX;\n    detail.startY = detail.currentY;\n    detail.startTimeStamp = detail.timeStamp;\n\n    if (onWillStart) {\n      onWillStart(detail).then(fireOnStart);\n    } else {\n      fireOnStart();\n    }\n\n    return true;\n  }\n\n  function fireOnStart() {\n    if (onStart) {\n      onStart(detail);\n    }\n\n    hasFiredStart = true;\n  }\n\n  function abortGesture() {\n    reset();\n    pointerEvents.stop();\n\n    if (notCaptured) {\n      notCaptured(detail);\n    }\n  }\n\n  function reset() {\n    hasCapturedPan = false;\n    hasStartedPan = false;\n    isMoveQueued = false;\n    hasFiredStart = true;\n    gesture.release();\n  } // END *************************\n\n\n  function pointerUp(ev) {\n    var tmpHasCaptured = hasCapturedPan;\n    var tmpHasFiredStart = hasFiredStart;\n    reset();\n\n    if (!tmpHasFiredStart) {\n      return;\n    }\n\n    calcGestureData(detail, ev); // Try to capture press\n\n    if (tmpHasCaptured) {\n      if (onEnd) {\n        onEnd(detail);\n      }\n\n      return;\n    } // Not captured any event\n\n\n    if (notCaptured) {\n      notCaptured(detail);\n    }\n  }\n\n  return {\n    setDisabled: function setDisabled(disabled) {\n      if (disabled && hasCapturedPan) {\n        pointerUp(undefined);\n      }\n\n      pointerEvents.setDisabled(disabled);\n    },\n    destroy: function destroy() {\n      gesture.destroy();\n      pointerEvents.destroy();\n    }\n  };\n}\n\nfunction calcGestureData(detail, ev) {\n  if (!ev) {\n    return;\n  }\n\n  var prevX = detail.currentX;\n  var prevY = detail.currentY;\n  var prevT = detail.timeStamp;\n  updateDetail(ev, detail);\n  var currentX = detail.currentX;\n  var currentY = detail.currentY;\n  var timestamp = detail.timeStamp = now(ev);\n  var timeDelta = timestamp - prevT;\n\n  if (timeDelta > 0 && timeDelta < 100) {\n    var velocityX = (currentX - prevX) / timeDelta;\n    var velocityY = (currentY - prevY) / timeDelta;\n    detail.velocityX = velocityX * 0.7 + detail.velocityX * 0.3;\n    detail.velocityY = velocityY * 0.7 + detail.velocityY * 0.3;\n  }\n\n  detail.deltaX = currentX - detail.startX;\n  detail.deltaY = currentY - detail.startY;\n  detail.event = ev;\n}\n\nfunction updateDetail(ev, detail) {\n  // get X coordinates for either a mouse click\n  // or a touch depending on the given event\n  var x = 0;\n  var y = 0;\n\n  if (ev) {\n    var changedTouches = ev.changedTouches;\n\n    if (changedTouches && changedTouches.length > 0) {\n      var touch = changedTouches[0];\n      x = touch.clientX;\n      y = touch.clientY;\n    } else if (ev.pageX !== undefined) {\n      x = ev.pageX;\n      y = ev.pageY;\n    }\n  }\n\n  detail.currentX = x;\n  detail.currentY = y;\n}\n\nfunction now(ev) {\n  return ev.timeStamp || Date.now();\n}\n\nexport { GESTURE_CONTROLLER, createGesture };","import './chunk-f257aad1.js';\nimport './chunk-1074393c.js';\nimport { createGesture } from './index-0303391f.js';\n\nfunction createSwipeBackGesture(el, canStartHandler, onStartHandler, onMoveHandler, onEndHandler) {\n  var win = el.ownerDocument.defaultView;\n\n  function canStart(detail) {\n    return detail.startX <= 50 && canStartHandler();\n  }\n\n  function onMove(detail) {\n    // set the transition animation's progress\n    var delta = detail.deltaX;\n    var stepValue = delta / win.innerWidth;\n    onMoveHandler(stepValue);\n  }\n\n  function onEnd(detail) {\n    // the swipe back gesture has ended\n    var delta = detail.deltaX;\n    var width = win.innerWidth;\n    var stepValue = delta / width;\n    var velocity = detail.velocityX;\n    var z = width / 2.0;\n    var shouldComplete = velocity >= 0 && (velocity > 0.2 || detail.deltaX > z);\n    var missing = shouldComplete ? 1 - stepValue : stepValue;\n    var missingDistance = missing * width;\n    var realDur = 0;\n\n    if (missingDistance > 5) {\n      var dur = missingDistance / Math.abs(velocity);\n      realDur = Math.min(dur, 300);\n    }\n\n    onEndHandler(shouldComplete, stepValue, realDur);\n  }\n\n  return createGesture({\n    el: el,\n    gestureName: 'goback-swipe',\n    gesturePriority: 40,\n    threshold: 10,\n    canStart: canStart,\n    onStart: onStartHandler,\n    onMove: onMove,\n    onEnd: onEnd\n  });\n}\n\nexport { createSwipeBackGesture };"],"sourceRoot":""}