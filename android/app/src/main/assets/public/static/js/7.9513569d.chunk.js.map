{"version":3,"sources":["../node_modules/@ionic/core/dist/esm/legacy/input-shims-667d45fc.js"],"names":["__webpack_require__","r","__webpack_exports__","d","startInputShims","_chunk_d102c9d1_js__WEBPACK_IMPORTED_MODULE_0__","cloneMap","WeakMap","relocateInput","componentEl","inputEl","shouldRelocate","inputRelativeY","has","parentEl","parentNode","clonedEl","cloneNode","classList","add","tabIndex","appendChild","set","tx","ownerDocument","dir","style","pointerEvents","transform","addClone","clone","get","delete","remove","removeClone","isFocused","input","getRootNode","activeElement","SKIP_SELECTOR","SCROLL_ASSIST_SPEED","getScrollData","contentEl","keyboardHeight","inputRect","contentRect","platformHeight","inputTop","top","inputBottom","bottom","visibleAreaTop","visibleAreaBottom","Math","min","safeAreaTop","distanceToBottom","distanceToTop","desiredScrollAmount","round","scrollAmount","duration","abs","scrollDuration","max","scrollPadding","inputSafeY","calcScrollData","closest","getBoundingClientRect","defaultView","innerHeight","enableScrollAssist","coord","touchStart","ev","Object","touchEnd","endCoord","threshold","startCoord","deltaX","x","deltaY","y","distance","hasPointerMoved","preventDefault","stopPropagation","scrollData","focus","scrollByPoint","then","jsSetFocus","addEventListener","removeEventListener","PADDING_TIMER_KEY","setScrollPadding","tagName","parentElement","el","timer","clearTimeout","setProperty","setTimeout","INPUT_BLURRING","SCROLL_PADDING","config","doc","document","getNumber","scrollAssist","getBoolean","hideCaret","inputBlurring","hideCaretMap","scrollAssistMap","registerInput","shadowRoot","querySelector","scrollEl","rmFn","scrollHideCaret","shouldHideCaret","onBlur","showCaret","enableHideCaretOnScroll","focused","didScroll","onScroll","onFocusin","onTouchend","active","matches","tapped","target","blur","enableInputBlurring","onFocusout","enableScrollPadding","_i","inputs_1","Array","from","querySelectorAll","length","body","event","fn","unregisterInput"],"mappings":"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","file":"static/js/7.9513569d.chunk.js","sourcesContent":["import { p as pointerCoord } from './chunk-d102c9d1.js';\nvar cloneMap = new WeakMap();\n\nfunction relocateInput(componentEl, inputEl, shouldRelocate, inputRelativeY) {\n  if (inputRelativeY === void 0) {\n    inputRelativeY = 0;\n  }\n\n  if (cloneMap.has(componentEl) === shouldRelocate) {\n    return;\n  }\n\n  if (shouldRelocate) {\n    addClone(componentEl, inputEl, inputRelativeY);\n  } else {\n    removeClone(componentEl, inputEl);\n  }\n}\n\nfunction isFocused(input) {\n  return input === input.getRootNode().activeElement;\n}\n\nfunction addClone(componentEl, inputEl, inputRelativeY) {\n  // this allows for the actual input to receive the focus from\n  // the user's touch event, but before it receives focus, it\n  // moves the actual input to a location that will not screw\n  // up the app's layout, and does not allow the native browser\n  // to attempt to scroll the input into place (messing up headers/footers)\n  // the cloned input fills the area of where native input should be\n  // while the native input fakes out the browser by relocating itself\n  // before it receives the actual focus event\n  // We hide the focused input (with the visible caret) invisible by making it scale(0),\n  var parentEl = inputEl.parentNode; // DOM WRITES\n\n  var clonedEl = inputEl.cloneNode(false);\n  clonedEl.classList.add('cloned-input');\n  clonedEl.tabIndex = -1;\n  parentEl.appendChild(clonedEl);\n  cloneMap.set(componentEl, clonedEl);\n  var doc = componentEl.ownerDocument;\n  var tx = doc.dir === 'rtl' ? 9999 : -9999;\n  componentEl.style.pointerEvents = 'none';\n  inputEl.style.transform = \"translate3d(\" + tx + \"px,\" + inputRelativeY + \"px,0) scale(0)\";\n}\n\nfunction removeClone(componentEl, inputEl) {\n  var clone = cloneMap.get(componentEl);\n\n  if (clone) {\n    cloneMap.delete(componentEl);\n    clone.remove();\n  }\n\n  componentEl.style.pointerEvents = '';\n  inputEl.style.transform = '';\n}\n\nfunction enableHideCaretOnScroll(componentEl, inputEl, scrollEl) {\n  if (!scrollEl || !inputEl) {\n    return function () {\n      return;\n    };\n  }\n\n  var scrollHideCaret = function scrollHideCaret(shouldHideCaret) {\n    if (isFocused(inputEl)) {\n      relocateInput(componentEl, inputEl, shouldHideCaret);\n    }\n  };\n\n  var onBlur = function onBlur() {\n    return relocateInput(componentEl, inputEl, false);\n  };\n\n  var hideCaret = function hideCaret() {\n    return scrollHideCaret(true);\n  };\n\n  var showCaret = function showCaret() {\n    return scrollHideCaret(false);\n  };\n\n  scrollEl.addEventListener('ionScrollStart', hideCaret);\n  scrollEl.addEventListener('ionScrollEnd', showCaret);\n  inputEl.addEventListener('blur', onBlur);\n  return function () {\n    scrollEl.removeEventListener('ionScrollStart', hideCaret);\n    scrollEl.removeEventListener('ionScrollEnd', showCaret);\n    inputEl.addEventListener('ionBlur', onBlur);\n  };\n}\n\nvar SKIP_SELECTOR = 'input, textarea, [no-blur]';\n\nfunction enableInputBlurring() {\n  var doc = document;\n  var focused = true;\n  var didScroll = false;\n\n  function onScroll() {\n    didScroll = true;\n  }\n\n  function onFocusin() {\n    focused = true;\n  }\n\n  function onTouchend(ev) {\n    // if app did scroll return early\n    if (didScroll) {\n      didScroll = false;\n      return;\n    }\n\n    var active = doc.activeElement;\n\n    if (!active) {\n      return;\n    } // only blur if the active element is a text-input or a textarea\n\n\n    if (active.matches(SKIP_SELECTOR)) {\n      return;\n    } // if the selected target is the active element, do not blur\n\n\n    var tapped = ev.target;\n\n    if (tapped === active) {\n      return;\n    }\n\n    if (tapped.matches(SKIP_SELECTOR) || tapped.closest(SKIP_SELECTOR)) {\n      return;\n    }\n\n    focused = false; // TODO: find a better way, why 50ms?\n\n    setTimeout(function () {\n      if (!focused) {\n        active.blur();\n      }\n    }, 50);\n  }\n\n  doc.addEventListener('ionScrollStart', onScroll);\n  doc.addEventListener('focusin', onFocusin, true);\n  doc.addEventListener('touchend', onTouchend, false);\n  return function () {\n    doc.removeEventListener('ionScrollStart', onScroll, true);\n    doc.removeEventListener('focusin', onFocusin, true);\n    doc.removeEventListener('touchend', onTouchend, false);\n  };\n}\n\nvar SCROLL_ASSIST_SPEED = 0.3;\n\nfunction getScrollData(componentEl, contentEl, keyboardHeight) {\n  var itemEl = componentEl.closest('ion-item,[ion-item]') || componentEl;\n  return calcScrollData(itemEl.getBoundingClientRect(), contentEl.getBoundingClientRect(), keyboardHeight, componentEl.ownerDocument.defaultView.innerHeight);\n}\n\nfunction calcScrollData(inputRect, contentRect, keyboardHeight, platformHeight) {\n  // compute input's Y values relative to the body\n  var inputTop = inputRect.top;\n  var inputBottom = inputRect.bottom; // compute visible area\n\n  var visibleAreaTop = contentRect.top;\n  var visibleAreaBottom = Math.min(contentRect.bottom, platformHeight - keyboardHeight); // compute safe area\n\n  var safeAreaTop = visibleAreaTop + 15;\n  var safeAreaBottom = visibleAreaBottom * 0.5; // figure out if each edge of the input is within the safe area\n\n  var distanceToBottom = safeAreaBottom - inputBottom;\n  var distanceToTop = safeAreaTop - inputTop; // desiredScrollAmount is the negated distance to the safe area according to our calculations.\n\n  var desiredScrollAmount = Math.round(distanceToBottom < 0 ? -distanceToBottom : distanceToTop > 0 ? -distanceToTop : 0); // our calculations make some assumptions that aren't always true, like the keyboard being closed when an input\n  // gets focus, so make sure we don't scroll the input above the visible area\n\n  var scrollAmount = Math.min(desiredScrollAmount, inputTop - visibleAreaTop);\n  var distance = Math.abs(scrollAmount);\n  var duration = distance / SCROLL_ASSIST_SPEED;\n  var scrollDuration = Math.min(400, Math.max(150, duration));\n  return {\n    scrollAmount: scrollAmount,\n    scrollDuration: scrollDuration,\n    scrollPadding: keyboardHeight,\n    inputSafeY: -(inputTop - safeAreaTop) + 4\n  };\n}\n\nfunction enableScrollAssist(componentEl, inputEl, contentEl, keyboardHeight) {\n  var coord;\n\n  var touchStart = function touchStart(ev) {\n    coord = pointerCoord(ev);\n  };\n\n  var touchEnd = function touchEnd(ev) {\n    // input cover touchend/mouseup\n    if (!coord) {\n      return;\n    } // get where the touchend/mouseup ended\n\n\n    var endCoord = pointerCoord(ev); // focus this input if the pointer hasn't moved XX pixels\n    // and the input doesn't already have focus\n\n    if (!hasPointerMoved(6, coord, endCoord) && !isFocused(inputEl)) {\n      ev.preventDefault();\n      ev.stopPropagation(); // begin the input focus process\n\n      jsSetFocus(componentEl, inputEl, contentEl, keyboardHeight);\n    }\n  };\n\n  componentEl.addEventListener('touchstart', touchStart, true);\n  componentEl.addEventListener('touchend', touchEnd, true);\n  return function () {\n    componentEl.removeEventListener('touchstart', touchStart, true);\n    componentEl.removeEventListener('touchend', touchEnd, true);\n  };\n}\n\nfunction jsSetFocus(componentEl, inputEl, contentEl, keyboardHeight) {\n  var scrollData = getScrollData(componentEl, contentEl, keyboardHeight);\n\n  if (Math.abs(scrollData.scrollAmount) < 4) {\n    // the text input is in a safe position that doesn't\n    // require it to be scrolled into view, just set focus now\n    inputEl.focus();\n    return;\n  } // temporarily move the focus to the focus holder so the browser\n  // doesn't freak out while it's trying to get the input in place\n  // at this point the native text input still does not have focus\n\n\n  relocateInput(componentEl, inputEl, true, scrollData.inputSafeY);\n  inputEl.focus(); // scroll the input into place\n\n  contentEl.scrollByPoint(0, scrollData.scrollAmount, scrollData.scrollDuration).then(function () {\n    // the scroll view is in the correct position now\n    // give the native text input focus\n    relocateInput(componentEl, inputEl, false, scrollData.inputSafeY); // ensure this is the focused input\n\n    inputEl.focus();\n  });\n}\n\nfunction hasPointerMoved(threshold, startCoord, endCoord) {\n  if (startCoord && endCoord) {\n    var deltaX = startCoord.x - endCoord.x;\n    var deltaY = startCoord.y - endCoord.y;\n    var distance = deltaX * deltaX + deltaY * deltaY;\n    return distance > threshold * threshold;\n  }\n\n  return false;\n}\n\nvar PADDING_TIMER_KEY = '$ionPaddingTimer';\n\nfunction enableScrollPadding(keyboardHeight) {\n  var doc = document;\n\n  function onFocusin(ev) {\n    setScrollPadding(ev.target, keyboardHeight);\n  }\n\n  function onFocusout(ev) {\n    setScrollPadding(ev.target, 0);\n  }\n\n  doc.addEventListener('focusin', onFocusin);\n  doc.addEventListener('focusout', onFocusout);\n  return function () {\n    doc.removeEventListener('focusin', onFocusin);\n    doc.removeEventListener('focusout', onFocusout);\n  };\n}\n\nfunction setScrollPadding(input, keyboardHeight) {\n  if (input.tagName !== 'INPUT') {\n    return;\n  }\n\n  if (input.parentElement && input.parentElement.tagName === 'ION-INPUT') {\n    return;\n  }\n\n  if (input.parentElement && input.parentElement.parentElement && input.parentElement.parentElement.tagName === 'ION-SEARCHBAR') {\n    return;\n  }\n\n  var el = input.closest('ion-content');\n\n  if (el === null) {\n    return;\n  }\n\n  var timer = el[PADDING_TIMER_KEY];\n\n  if (timer) {\n    clearTimeout(timer);\n  }\n\n  if (keyboardHeight > 0) {\n    el.style.setProperty('--keyboard-offset', keyboardHeight + \"px\");\n  } else {\n    el[PADDING_TIMER_KEY] = setTimeout(function () {\n      el.style.setProperty('--keyboard-offset', '0px');\n    }, 120);\n  }\n}\n\nvar INPUT_BLURRING = true;\nvar SCROLL_PADDING = true;\n\nfunction startInputShims(config) {\n  var doc = document;\n  var keyboardHeight = config.getNumber('keyboardHeight', 290);\n  var scrollAssist = config.getBoolean('scrollAssist', true);\n  var hideCaret = config.getBoolean('hideCaretOnScroll', true);\n  var inputBlurring = config.getBoolean('inputBlurring', true);\n  var scrollPadding = config.getBoolean('scrollPadding', true);\n  var hideCaretMap = new WeakMap();\n  var scrollAssistMap = new WeakMap();\n\n  function registerInput(componentEl) {\n    var inputEl = (componentEl.shadowRoot || componentEl).querySelector('input') || (componentEl.shadowRoot || componentEl).querySelector('textarea');\n    var scrollEl = componentEl.closest('ion-content');\n\n    if (!inputEl) {\n      return;\n    }\n\n    if (!!scrollEl && hideCaret && !hideCaretMap.has(componentEl)) {\n      var rmFn = enableHideCaretOnScroll(componentEl, inputEl, scrollEl);\n      hideCaretMap.set(componentEl, rmFn);\n    }\n\n    if (!!scrollEl && scrollAssist && !scrollAssistMap.has(componentEl)) {\n      var rmFn = enableScrollAssist(componentEl, inputEl, scrollEl, keyboardHeight);\n      scrollAssistMap.set(componentEl, rmFn);\n    }\n  }\n\n  function unregisterInput(componentEl) {\n    if (hideCaret) {\n      var fn = hideCaretMap.get(componentEl);\n\n      if (fn) {\n        fn();\n      }\n\n      hideCaretMap.delete(componentEl);\n    }\n\n    if (scrollAssist) {\n      var fn = scrollAssistMap.get(componentEl);\n\n      if (fn) {\n        fn();\n      }\n\n      scrollAssistMap.delete(componentEl);\n    }\n  }\n\n  if (inputBlurring && INPUT_BLURRING) {\n    enableInputBlurring();\n  }\n\n  if (scrollPadding && SCROLL_PADDING) {\n    enableScrollPadding(keyboardHeight);\n  } // Input might be already loaded in the DOM before ion-device-hacks did.\n  // At this point we need to look for all of the inputs not registered yet\n  // and register them.\n\n\n  var inputs = Array.from(doc.querySelectorAll('ion-input, ion-textarea'));\n\n  for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {\n    var input = inputs_1[_i];\n    registerInput(input);\n  }\n\n  doc.body.addEventListener('ionInputDidLoad', function (event) {\n    registerInput(event.target);\n  });\n  doc.body.addEventListener('ionInputDidUnload', function (event) {\n    unregisterInput(event.target);\n  });\n}\n\nexport { startInputShims };"],"sourceRoot":""}